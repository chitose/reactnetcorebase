${
  using System.Collections;
  using System.IO;
  using Typewriter.Extensions.Types;
  using Typewriter.Extensions.WebApi;

  Template(Settings settings)
  {
    settings.OutputFilenameFactory = file => CamelCase(Path.GetFileNameWithoutExtension(file.Name).Replace("Controller", ""));
  }

  string CamelCase(string s)
  {
      if (string.IsNullOrEmpty(s)) return s;
      if (char.IsUpper(s[0]) == false) return s;
      var chars = s.ToCharArray();
      chars[0] = char.ToLowerInvariant(chars[0]);
      return new string(chars);
  }

  // HACK: see https://github.com/frhagn/Typewriter/issues/115
  static readonly string[] attributes = new[] { "HttpGet", "HttpDelete", "HttpPost", "HttpPut", "Route" };
  string UrlCore(Method method)
  {
    var @class = method.Parent as Class;
    string route = @class.Attributes.FirstOrDefault(a => a.Name == "Route")?.Value?.TrimEnd('/') ?? "api/[controller]";
    var methodRoute = method.Attributes.FirstOrDefault(a => attributes.Contains(a.Name))?.Value;
    if (methodRoute != null) route = route + "/" + methodRoute;
    return UrlExtensions.Url(method, "/" + route);
  }

  string JsonBody(Method method)
  {
    // Find a FromBody param if any
    foreach (var p in method.Parameters)
    {
      if (!p.Attributes.Any(a => a.Name == "FromBody")) continue;
      return ", body: JSON.stringify(" + p.Name + ")";
    }
    return "";
  }


  string ReturnType(Method method)
  {
    var type = method.Type;
    if (!type.IsDefined && !type.IsPrimitive)
    {
      // ActionResult methods are converted to type any, since we do not know what they actually send
      var parent = type.BaseClass;
      while (parent != null)
      {
        if (parent.Name == "ActionResult") return "any";
        parent = parent.BaseClass;
      }
    }
    return type.Name;
  }

  string ParamType(Parameter parameter)
  {
    var result = parameter.Type;
    return result.Unwrap() == "IFormFile" ? "never" : result;
  }

  IEnumerable<Property> AllProperties(Type t) {
    var c = t.BaseClass;
    while (c != null) {
      foreach (var p in c.Properties)
        yield return p;
      c = c.BaseClass;
    }
    foreach (var p in t.Properties)
      yield return p;
  }

  static Dictionary<Class, IEnumerable<Type>> DependenciesCache = new Dictionary<Class, IEnumerable<Type>>();

  private bool Visited(Type type, Dictionary<string, Type> set)
  {
    if (type.IsDefined && !set.ContainsKey(type.Name))
    {
      set.Add(type.Name, type);
      return true;
    }
    return false;
  }

  private void VisitTypes(Type type, Dictionary<string, Type> set)
  {
    foreach (var p in type.Properties) {
      var t = p.Type.Unwrap();
      if (Visited(t, set))
        VisitTypes(t, set);
    }
  }

  private void VisitTypes(Method method, Dictionary<string, Type> set)
  {
    var t = method.Type.Unwrap();
    if (Visited(t, set))
      VisitTypes(t, set);
    foreach (var p in method.Parameters)
    {
      if (p.Attributes.Any(a => a.Name == "FromServices")) continue;
      t = p.Type.Unwrap();
      if (Visited(t, set))
        VisitTypes(t, set);
    }
  }

  // Gets the list of all non primitive types exposed by an API controller
  IEnumerable<Type> Dependencies(Class @class)
  {
    IEnumerable<Type> result;
    if (DependenciesCache.TryGetValue(@class, out result)) return result;

    var set = new Dictionary<string, Type>();
    foreach (var m in @class.Methods)
      VisitTypes(m, set);
    result = set.Values;

    DependenciesCache.Add(@class, result);
    return result;
  }

  bool HasEnumDependencies(Class @class) => Dependencies(@class).Any(x => x.IsEnum);
  IEnumerable<Type> EnumDependencies(Class @class) => Dependencies(@class).Where(t => t.IsEnum);
  IEnumerable<Type> DbClassDependencies(Class @class) => Dependencies(@class).Where(t => !t.IsEnum && t.FullName.Contains(".Models.Db."));
  IEnumerable<Type> ViewClassDependencies(Class @class) => Dependencies(@class).Where(t => !t.IsEnum && t.FullName.Contains(".Models.View."));
  bool HasParameter(Method @method) => @method.Parameters.Where(p=> !p.Attributes.Any(a => a.Name == "FromServices")).Count()>0;
  bool NoParameter(Method @method) => @method.Parameters.Where(p=> !p.Attributes.Any(a => a.Name == "FromServices")).Count()==0;  
}
// Auto generated by typewriter from c# code. Update coresponding c# code to re-generate this file.
import {ApiResponse} from '../model/view/apiResponse';
import {HttpClientAPI} from '../provider/httpClient';
$Classes(:BaseApiController)[$DbClassDependencies[
import {$Name} from '../model/db/$name';
]
$ViewClassDependencies[import {$Name} from '../model/view/$name';
]
$HasEnumDependencies[import { $EnumDependencies[$Name][, ] } from '../model/enums';]

$Methods(m => m.HttpMethod() == "get")[$HasParameter[export function get_$name_URL($Parameters(p => !p.Attributes.Any(a => a.Name == "FromServices" && a.Name == "FromBody"))[$name: $ParamType][, ]) {
  return `$UrlCore`;
}]]
$Methods[$HasParameter[export function $name(api: HttpClientAPI,$Parameters(p => !p.Attributes.Any(a => a.Name == "FromServices"))[$name: $ParamType][, ]) {
  return api.http<ApiResponse<$ReturnType>>(`$UrlCore`, { method: '$HttpMethod' $JsonBody });
}]
$NoParameter[export const $name_URL = '$UrlCore';
export function $name(api: HttpClientAPI) {
  return api.http<ApiResponse<$ReturnType>>('$UrlCore', { method: '$HttpMethod' $JsonBody });
}]]]